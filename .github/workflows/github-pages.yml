name: Build Module Documentation

on:
  push:
    branches: [ main ]
    paths:
      - 'Public/**'
      - 'docs/**'
      - '.github/workflows/github-pages.yml'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-docs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout ActionableMessages repository
        uses: actions/checkout@v3
        with:
          path: actionable-messages

      - name: Checkout GitHub Pages repository
        uses: actions/checkout@v3
        with:
          repository: Mynster9361/mynster9361.github.io
          token: ${{ secrets.GH_PAGES_TOKEN }}
          path: github-pages

      - name: Setup PowerShell
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '7.0.x'

      - name: Install PowerShell modules
        shell: pwsh
        run: |
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
          Install-Module -Name PlatyPS -Force

      - name: Generate docs
        shell: pwsh
        run: |
          # Import module from ActionableMessages repo
          Import-Module ./actionable-messages/ActionableMessages.psd1 -Force

          # Create module collection directory in GitHub Pages repo
          $targetDir = "./github-pages/_powershell_modules/actionablemessages"
          New-Item -ItemType Directory -Path $targetDir -Force
          $cmdDocsPath = "$targetDir/commands"
          New-Item -ItemType Directory -Path $cmdDocsPath -Force

          function Convert-TypeName($TypeName) {
            # Convert full .NET type names to simpler display versions
            $TypeName = $TypeName -replace "System\.", ""
            return $TypeName
          }

          function Get-ParameterInfo($Command) {
            $info = @()
            foreach ($parameter in $Command.Parameters.Keys) {
              $parameterInfo = $Command.Parameters[$parameter]
              $paramObj = [PSCustomObject]@{
                Name = $parameter
                Type = Convert-TypeName $parameterInfo.ParameterType.FullName
                Required = $parameterInfo.Attributes.Where({$_ -is [System.Management.Automation.ParameterAttribute]}).Mandatory
                Position = $parameterInfo.Attributes.Where({$_ -is [System.Management.Automation.ParameterAttribute]}).Position
                PipelineInput = $parameterInfo.Attributes.Where({$_ -is [System.Management.Automation.ParameterAttribute]}).ValueFromPipeline -or
                                $parameterInfo.Attributes.Where({$_ -is [System.Management.Automation.ParameterAttribute]}).ValueFromPipelineByPropertyName
                DefaultValue = if ($parameterInfo.DefaultValue -ne $null -and $parameterInfo.DefaultValue.ToString() -ne "System.Object") { $parameterInfo.DefaultValue } else { "None" }
                AcceptWildcards = $parameterInfo.Attributes.Where({$_ -is [System.Management.Automation.ParameterAttribute]}).ValueFromRemainingArguments
              }
              $info += $paramObj
            }
            return $info | Sort-Object -Property Position, Name
          }

          function Get-CleanSyntax($Command) {
            # Get a clean syntax representation
            $params = $Command.Parameters.Values | Where-Object { -not $_.IsDynamic }

            $syntax = "$($Command.Name) "
            $paramSyntax = $params | ForEach-Object {
              $param = $_
              $attributes = $param.Attributes | Where-Object { $_ -is [System.Management.Automation.ParameterAttribute] }
              $mandatory = $attributes | Where-Object { $_.Mandatory }

              if ($mandatory) {
                "[-$($param.Name)] <$($param.ParameterType.Name)>"
              } else {
                "[-$($param.Name) <$($param.ParameterType.Name)>]"
              }
            }

            $syntax += $paramSyntax -join " "
            $syntax += " [<CommonParameters>]"

            return $syntax
          }

          function Get-CommandDocumentation($CommandName, $OutputPath) {
            $command = Get-Command $CommandName
            $help = Get-Help $CommandName -Full

            # Get command examples
            $examples = $help.Examples.Example | ForEach-Object {
              [PSCustomObject]@{
                Title = $_.Title.Replace("--------------------------  ", "").Trim()
                Code = $_.Code.Trim()
                Remarks = $_.Remarks.Text.Trim()
              }
            }

            # Get parameter information
            $parameters = Get-ParameterInfo $command

            # Get the syntax first to avoid issues with nested function calls
            $syntax = Get-CleanSyntax $command

            # Pre-process help text to avoid issues with special characters
            $synopsis = if ($help.Synopsis) { $help.Synopsis.Trim() } else { "No synopsis available." }
            $description = if ($help.Description.Text) { $help.Description.Text.Trim() } else { "No description available." }

            # Use string concatenation instead of StringBuilder to avoid parsing issues
            $lines = @()
            $lines += "---"
            $lines += "layout: page"
            $lines += "title: $CommandName"
            $lines += "permalink: /modules/actionablemessages/commands/$CommandName/"
            $lines += "---"
            $lines += ""
            $lines += "# $CommandName"
            $lines += ""
            $lines += "## SYNOPSIS"
            $lines += $synopsis
            $lines += ""
            $lines += "## SYNTAX"
            $lines += ""
            $lines += "```powershell"
            $lines += $syntax
            $lines += "```"
            $lines += ""
            $lines += "## DESCRIPTION"
            $lines += $description
            $lines += ""
            $lines += "## EXAMPLES"

            # Add examples
            $exampleNumber = 1
            foreach ($example in $examples) {
              $lines += ""
              $lines += "### EXAMPLE $exampleNumber"
              $lines += "```powershell"
              $lines += $example.Code
              $lines += "```"
              $lines += ""
              if ($example.Remarks) {
                $lines += $example.Remarks
                $lines += ""
              }
              $exampleNumber++
            }

            # Add parameters section
            $lines += "## PARAMETERS"

            # First add the regular parameters (non-common)
            foreach ($parameter in $parameters | Where-Object { $_.Name -notmatch '^(Debug|ErrorAction|ErrorVariable|InformationAction|InformationVariable|OutBuffer|OutVariable|PipelineVariable|ProgressAction|Verbose|WarningAction|WarningVariable)$' }) {
              $paramHelp = $help.Parameters.Parameter | Where-Object { $_.Name -eq $parameter.Name }
              $lines += ""
              $lines += "### -$($parameter.Name)"
              if ($paramHelp.Description.Text) {
                $lines += $paramHelp.Description.Text
                $lines += ""
              }
              $lines += "```yaml"
              $lines += "Type: $($parameter.Type)"
              $lines += "Parameter Sets: $(if ($paramHelp.ParameterSetName) { $paramHelp.ParameterSetName } else { "(All)" })"
              $lines += "Aliases: $(if ($paramHelp.Aliases) { $paramHelp.Aliases } else { "None" })"
              $lines += ""
              $lines += "Required: $($parameter.Required)"
              $lines += "Position: $($parameter.Position)"
              $lines += "Default value: $($parameter.DefaultValue)"
              $lines += "Accept pipeline input: $($parameter.PipelineInput)"
              $lines += "Accept wildcard characters: $($parameter.AcceptWildcards)"
              $lines += "```"
            }

            # Add Common Parameters section
            $lines += ""
            $lines += "### CommonParameters"
            $lines += "This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see [about_CommonParameters](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_commonparameters)."

            # Add inputs and outputs sections
            $lines += ""
            $lines += "## INPUTS"
            if ($help.InputTypes.InputType.Type.Name) {
              $lines += "### $($help.InputTypes.InputType.Type.Name)"
              if ($help.InputTypes.InputType.Description.Text) {
                $lines += $help.InputTypes.InputType.Description.Text
              }
            } else {
              $lines += "### None"
            }

            $lines += ""
            $lines += "## OUTPUTS"
            if ($help.ReturnValues.ReturnValue.Type.Name) {
              $lines += "### $($help.ReturnValues.ReturnValue.Type.Name)"
              if ($help.ReturnValues.ReturnValue.Description.Text) {
                $lines += $help.ReturnValues.ReturnValue.Description.Text
              }
            } else {
              $lines += "### None"
            }

            # Add notes and links
            if ($help.AlertSet.Alert) {
              $lines += ""
              $lines += "## NOTES"
              $lines += $help.AlertSet.Alert.Text
            }

            if ($help.RelatedLinks.NavigationLink) {
              $lines += ""
              $lines += "## RELATED LINKS"
              foreach ($link in $help.RelatedLinks.NavigationLink) {
                if ($link.Uri) {
                  $lines += "* [$($link.LinkText)]($($link.Uri))"
                } else {
                  $lines += "* $($link.LinkText)"
                }
              }
            }

            # Write the markdown file with LF line endings to avoid the ``r issue
            $content = $lines -join "`n"
            [System.IO.File]::WriteAllText($OutputPath, $content)
          }

          # Generate documentation for each command in the module
          $commands = Get-Command -Module ActionableMessages
          foreach ($command in $commands) {
            Write-Host "Generating documentation for $($command.Name)"
            $outputFile = Join-Path $cmdDocsPath "$($command.Name).md"
            Get-CommandDocumentation -CommandName $command.Name -OutputPath $outputFile
          }

          # Create commands index page with array joining for consistent formatting
          $lines = @(
            "---",
            "layout: page",
            "title: ActionableMessages Commands",
            "permalink: /modules/actionablemessages/commands/",
            "---",
            "",
            "# ActionableMessages Commands",
            ""
          )

          foreach ($command in ($commands | Sort-Object -Property Name)) {
            $lines += "* [``$($command.Name)``]($($command.Name)/)"
          }

          $commandsIndexPath = "$cmdDocsPath/index.md"
          $commandsIndexContent = $lines -join "`n"
          [System.IO.File]::WriteAllText($commandsIndexPath, $commandsIndexContent)

          # Create main index page with array joining
          $lines = @(
            "---",
            "layout: page",
            "title: ActionableMessages PowerShell Module",
            "permalink: /modules/actionablemessages/",
            "---",
            "",
            "# ActionableMessages PowerShell Module",
            "",
            "A PowerShell module for creating Microsoft Actionable Messages.",
            "",
            "## Installation",
            "",
            "```powershell",
            "Install-Module -Name ActionableMessages -Scope CurrentUser",
            "```",
            "",
            "## Quick Start",
            "",
            "```powershell",
            '$card = New-AMCard -ThemeColor "#0078D7"',
            'Add-AMElement -InputObject $card -Element (New-AMTextBlock -Text "Hello, World!")',
            '$jsonCard = Export-AMCard -Card $card',
            "```",
            "",
            "## Command Reference",
            ""
          )

          foreach ($command in ($commands | Sort-Object -Property Name)) {
            $lines += "* [``$($command.Name)``](commands/$($command.Name)/)"
          }

          $mainIndexPath = "$targetDir/index.md"
          $mainIndexContent = $lines -join "`n"
          [System.IO.File]::WriteAllText($mainIndexPath, $mainIndexContent)

      - name: Commit documentation to GitHub Pages repo
        run: |
          cd github-pages
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add ./_powershell_modules
          git commit -m "Update ActionableMessages module documentation" || echo "No changes to commit"
          git push