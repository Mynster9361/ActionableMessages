name: Build Module Documentation

on:
  push:
    branches: [ main ]
    paths:
      - 'Public/**'
      - 'docs/**'
      - '.github/workflows/github-pages.yml'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-docs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout ActionableMessages repository
        uses: actions/checkout@v3
        with:
          path: actionable-messages

      - name: Checkout GitHub Pages repository
        uses: actions/checkout@v3
        with:
          repository: Mynster9361/mynster9361.github.io
          token: ${{ secrets.GH_PAGES_TOKEN }}
          path: github-pages

      - name: Setup PowerShell
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '7.0.x'

      - name: Install PowerShell modules
        shell: pwsh
        run: |
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
          Install-Module -Name PlatyPS -Force

      - name: Generate docs
        shell: pwsh
        run: |
          # Import module from ActionableMessages repo
          Import-Module ./actionable-messages/ActionableMessages.psd1 -Force

          # Create module collection directory in GitHub Pages repo
          $targetDir = "./github-pages/_powershell_modules/actionablemessages"
          New-Item -ItemType Directory -Path $targetDir -Force
          $cmdDocsPath = "$targetDir/commands"
          New-Item -ItemType Directory -Path $cmdDocsPath -Force

          function Convert-TypeName($TypeName) {
            # Convert full .NET type names to simpler display versions
            $TypeName = $TypeName -replace "System\.", ""
            return $TypeName
          }

          function Get-ParameterInfo($Command) {
            $info = @()
            foreach ($parameter in $Command.Parameters.Keys) {
              $parameterInfo = $Command.Parameters[$parameter]
              $paramObj = [PSCustomObject]@{
                Name = $parameter
                Type = Convert-TypeName $parameterInfo.ParameterType.FullName
                Required = $parameterInfo.Attributes.Where({$_ -is [System.Management.Automation.ParameterAttribute]}).Mandatory
                Position = $parameterInfo.Attributes.Where({$_ -is [System.Management.Automation.ParameterAttribute]}).Position
                PipelineInput = $parameterInfo.Attributes.Where({$_ -is [System.Management.Automation.ParameterAttribute]}).ValueFromPipeline -or
                                $parameterInfo.Attributes.Where({$_ -is [System.Management.Automation.ParameterAttribute]}).ValueFromPipelineByPropertyName
                DefaultValue = if ($parameterInfo.DefaultValue -ne $null -and $parameterInfo.DefaultValue.ToString() -ne "System.Object") { $parameterInfo.DefaultValue } else { "None" }
                AcceptWildcards = $parameterInfo.Attributes.Where({$_ -is [System.Management.Automation.ParameterAttribute]}).ValueFromRemainingArguments
              }
              $info += $paramObj
            }
            return $info | Sort-Object -Property Position, Name
          }

          function Get-CleanSyntax($Command) {
            # Get a clean syntax representation
            $params = $Command.Parameters.Values | Where-Object { -not $_.IsDynamic }

            $syntax = "$($Command.Name) "
            $paramSyntax = $params | ForEach-Object {
              $param = $_
              $attributes = $param.Attributes | Where-Object { $_ -is [System.Management.Automation.ParameterAttribute] }
              $mandatory = $attributes | Where-Object { $_.Mandatory }

              if ($mandatory) {
                "[-$($param.Name)] <$($param.ParameterType.Name)>"
              } else {
                "[-$($param.Name) <$($param.ParameterType.Name)>]"
              }
            }

            $syntax += $paramSyntax -join " "
            $syntax += " [<CommonParameters>]"

            return $syntax
          }

          function Get-CommandDocumentation($CommandName, $OutputPath) {
            $command = Get-Command $CommandName
            $help = Get-Help $CommandName -Full

            # Get command examples
            $examples = $help.Examples.Example | ForEach-Object {
              [PSCustomObject]@{
                Title = $_.Title.Replace("--------------------------  ", "").Trim()
                Code = $_.Code.Trim()
                Remarks = $_.Remarks.Text.Trim()
              }
            }

            # Get parameter information
            $parameters = Get-ParameterInfo $command

            # Get the syntax first to avoid issues with nested function calls
            $syntax = Get-CleanSyntax $command

            # Create front matter section
            $sb = [System.Text.StringBuilder]::new()
            [void]$sb.AppendLine("---")
            [void]$sb.AppendLine("layout: page")
            [void]$sb.AppendLine("title: $CommandName")
            [void]$sb.AppendLine("permalink: /modules/actionablemessages/commands/$CommandName/")
            [void]$sb.AppendLine("---")
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("# $CommandName")
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("## SYNOPSIS")
            [void]$sb.AppendLine($help.Synopsis)
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("## SYNTAX")
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("```powershell")
            [void]$sb.AppendLine($syntax)
            [void]$sb.AppendLine("```")
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("## DESCRIPTION")
            [void]$sb.AppendLine($help.Description.Text)
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("## EXAMPLES")

            # Add examples
            $exampleNumber = 1
            foreach ($example in $examples) {
              [void]$sb.AppendLine("")
              [void]$sb.AppendLine("### EXAMPLE $exampleNumber")
              [void]$sb.AppendLine("```powershell")
              [void]$sb.AppendLine($example.Code)
              [void]$sb.AppendLine("```")
              [void]$sb.AppendLine("")
              if ($example.Remarks) {
                [void]$sb.AppendLine($example.Remarks)
                [void]$sb.AppendLine("")
              }
              $exampleNumber++
            }

            # Add parameters section
            [void]$sb.AppendLine("## PARAMETERS")

            # First add the regular parameters (non-common)
            foreach ($parameter in $parameters | Where-Object { $_.Name -notmatch '^(Debug|ErrorAction|ErrorVariable|InformationAction|InformationVariable|OutBuffer|OutVariable|PipelineVariable|ProgressAction|Verbose|WarningAction|WarningVariable)$' }) {
              $paramHelp = $help.Parameters.Parameter | Where-Object { $_.Name -eq $parameter.Name }
              [void]$sb.AppendLine("")
              [void]$sb.AppendLine("### -$($parameter.Name)")
              if ($paramHelp.Description.Text) {
                [void]$sb.AppendLine($paramHelp.Description.Text)
                [void]$sb.AppendLine("")
              }
              [void]$sb.AppendLine("```yaml")
              [void]$sb.AppendLine("Type: $($parameter.Type)")
              [void]$sb.AppendLine("Parameter Sets: $(if ($paramHelp.ParameterSetName) { $paramHelp.ParameterSetName } else { "(All)" })")
              [void]$sb.AppendLine("Aliases: $(if ($paramHelp.Aliases) { $paramHelp.Aliases } else { "None" })")
              [void]$sb.AppendLine("")
              [void]$sb.AppendLine("Required: $($parameter.Required)")
              [void]$sb.AppendLine("Position: $($parameter.Position)")
              [void]$sb.AppendLine("Default value: $($parameter.DefaultValue)")
              [void]$sb.AppendLine("Accept pipeline input: $($parameter.PipelineInput)")
              [void]$sb.AppendLine("Accept wildcard characters: $($parameter.AcceptWildcards)")
              [void]$sb.AppendLine("```")
            }

            # Add Common Parameters section
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("### CommonParameters")
            [void]$sb.AppendLine("This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see [about_CommonParameters](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_commonparameters).")

            # Add inputs and outputs sections
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("## INPUTS")
            if ($help.InputTypes.InputType.Type.Name) {
              [void]$sb.AppendLine("### $($help.InputTypes.InputType.Type.Name)")
              if ($help.InputTypes.InputType.Description.Text) {
                [void]$sb.AppendLine($help.InputTypes.InputType.Description.Text)
              }
            } else {
              [void]$sb.AppendLine("### None")
            }

            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("## OUTPUTS")
            if ($help.ReturnValues.ReturnValue.Type.Name) {
              [void]$sb.AppendLine("### $($help.ReturnValues.ReturnValue.Type.Name)")
              if ($help.ReturnValues.ReturnValue.Description.Text) {
                [void]$sb.AppendLine($help.ReturnValues.ReturnValue.Description.Text)
              }
            } else {
              [void]$sb.AppendLine("### None")
            }

            # Add notes and links
            if ($help.AlertSet.Alert) {
              [void]$sb.AppendLine("")
              [void]$sb.AppendLine("## NOTES")
              [void]$sb.AppendLine($help.AlertSet.Alert.Text)
            }

            if ($help.RelatedLinks.NavigationLink) {
              [void]$sb.AppendLine("")
              [void]$sb.AppendLine("## RELATED LINKS")
              foreach ($link in $help.RelatedLinks.NavigationLink) {
                if ($link.Uri) {
                  [void]$sb.AppendLine("* [$($link.LinkText)]($($link.Uri))")
                } else {
                  [void]$sb.AppendLine("* $($link.LinkText)")
                }
              }
            }

            # Write the markdown file with LF line endings to avoid the ``r issue
            $content = $sb.ToString() -replace "`r`n", "`n"
            [System.IO.File]::WriteAllText($OutputPath, $content)
          }

          # Generate documentation for each command in the module
          $commands = Get-Command -Module ActionableMessages
          foreach ($command in $commands) {
            Write-Host "Generating documentation for $($command.Name)"
            $outputFile = Join-Path $cmdDocsPath "$($command.Name).md"
            Get-CommandDocumentation -CommandName $command.Name -OutputPath $outputFile
          }

          # Create commands index page with StringBuilder for consistent formatting
          $sb = [System.Text.StringBuilder]::new()
          [void]$sb.AppendLine("---")
          [void]$sb.AppendLine("layout: page")
          [void]$sb.AppendLine("title: ActionableMessages Commands")
          [void]$sb.AppendLine("permalink: /modules/actionablemessages/commands/")
          [void]$sb.AppendLine("---")
          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("# ActionableMessages Commands")
          [void]$sb.AppendLine("")

          foreach ($command in ($commands | Sort-Object -Property Name)) {
            [void]$sb.AppendLine("* [``$($command.Name)``]($($command.Name)/)")
          }

          $commandsIndexPath = "$cmdDocsPath/index.md"
          $commandsIndexContent = $sb.ToString() -replace "`r`n", "`n"
          [System.IO.File]::WriteAllText($commandsIndexPath, $commandsIndexContent)

          # Create main index page with StringBuilder
          $sb = [System.Text.StringBuilder]::new()
          [void]$sb.AppendLine("---")
          [void]$sb.AppendLine("layout: page")
          [void]$sb.AppendLine("title: ActionableMessages PowerShell Module")
          [void]$sb.AppendLine("permalink: /modules/actionablemessages/")
          [void]$sb.AppendLine("---")
          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("# ActionableMessages PowerShell Module")
          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("A PowerShell module for creating Microsoft Actionable Messages.")
          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("## Installation")
          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("```powershell")
          [void]$sb.AppendLine("Install-Module -Name ActionableMessages -Scope CurrentUser")
          [void]$sb.AppendLine("```")
          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("## Quick Start")
          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("```powershell")
          [void]$sb.AppendLine('$card = New-AMCard -ThemeColor "#0078D7"')
          [void]$sb.AppendLine('Add-AMElement -InputObject $card -Element (New-AMTextBlock -Text "Hello, World!")')
          [void]$sb.AppendLine('$jsonCard = Export-AMCard -Card $card')
          [void]$sb.AppendLine("```")
          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("## Command Reference")
          [void]$sb.AppendLine("")

          foreach ($command in ($commands | Sort-Object -Property Name)) {
            [void]$sb.AppendLine("* [``$($command.Name)``](commands/$($command.Name)/)")
          }

          $mainIndexPath = "$targetDir/index.md"
          $mainIndexContent = $sb.ToString() -replace "`r`n", "`n"
          [System.IO.File]::WriteAllText($mainIndexPath, $mainIndexContent)

      - name: Commit documentation to GitHub Pages repo
        run: |
          cd github-pages
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add ./_powershell_modules
          git commit -m "Update ActionableMessages module documentation" || echo "No changes to commit"
          git push